'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
/** @jsx h */

var _escapeHtml = require('escape-html');

var _escapeHtml2 = _interopRequireDefault(_escapeHtml);

var _helpers = require('./helpers');

var Helpers = _interopRequireWildcard(_helpers);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function h(name) {
  for (var _len = arguments.length, children = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }

  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return {
    name: name,
    props: props,
    children: children
  };
}

function handleString(item, options) {
  if (options.escape) {
    return (0, _escapeHtml2.default)(item);
  }
  return item;
}

function handleArray(items, options) {
  // eslint-disable-next-line no-use-before-define
  return items.map(function (item) {
    return handle(item, options);
  }).join('');
}

function handleObect(item, options) {
  var attributes = [];
  if (item.props !== null) {
    var props = Object.keys(item.props);
    for (var i = 0, length = props.length; i < length; ++i) {
      var name = props[i];
      var value = item.props[name];
      if (typeof value !== 'undefined' && value !== 'null') {
        var renderFriendlyName = name.replace(/_/g, ':');
        attributes.push(renderFriendlyName + '="' + (0, _escapeHtml2.default)(value) + '"');
      }
    }
  }
  var itemName = item.name.replace(/_/g, ':');
  var openingTag = '<' + itemName + (attributes.length ? ' ' + attributes.join(' ') : '') + '>';
  if (!item.children.length) {
    return openingTag.slice(0, -1) + ' />';
  }

  var output = [openingTag];
  // eslint-disable-next-line no-use-before-define
  var children = handle(item.children, options);
  if (children.length) {
    output.push(children);
  }
  output.push('</' + item.name + '>');
  return output.join('');
}

function handle(item, options) {
  var type = typeof item === 'undefined' ? 'undefined' : _typeof(item);
  if (type === 'undefined' || item === null) {
    return '';
  }
  if (type === 'number' || type === 'boolean') {
    return item.toString();
  }
  if (type === 'string') {
    return handleString(item, options);
  }
  if (Array.isArray(item)) {
    return handleArray(item, options);
  }
  if (type === 'object') {
    return handleObect(item, options);
  }
  throw new Error('Unrecognized input type provided to jsx-string: ' + type);
}

module.exports = function (input, options) {
  return handle(input, Helpers.fillOptions(options));
};
module.exports.h = h;